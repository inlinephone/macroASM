#include "parser.h"

Parser::Parser(QTextBrowser *_console, const QString& _masmFilePath)
    : console(_console), masmFilePath(_masmFilePath)
{

}

void Parser::runParser()
{
    QFile masmFile(masmFilePath);

    if(!masmFile.open(QIODevice::Text | QIODevice::ReadOnly))
    {
        console.prim_cerr("Невозможно открыть файл \"" + masmFilePath + "\"");
        return;
    }

    QTextStream masmStream(&masmFile);

    console.prim_clog("Разбор файла начат");

    if(parseMasmFile(masmStream))
        console.prim_clog("Разбор файла успешно завершен");
    else
        console.prim_cerr("Не удалось разобрать файл");

    masmFile.close();
    database.clear();
}

QString Parser::getDirectory(const QString &path)
{
    auto iter = path.size() - 1;                   // Устанавливаем iter в последний элемент, так как поиск осуществляем с конца
    for(; iter > -1 && path[iter] != '/'; --iter); // Ищем '/', который определяет начало директории

    QString directotyPath = path;

    directotyPath.truncate(iter);   // Обрезаем всё, до iter (то есть оставляем только путь к директории без '/')

    return directotyPath + '/';
}

bool Parser::parseMasmFile(QTextStream &stream)
{
    QString line;
    QFile outAsmFile(getDirectory(masmFilePath) + "ASM_AUTOGENERATED_FILE.uum32asm");

    MacroCallDeployer::resetAdditionalPostfix(); // Сбросим текущий добавочный постфикс (для повторного использования)
    console.setCurrentFile(masmFilePath);

    if(!outAsmFile.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate))
    {
        console.prim_cerr("Невозможно создать файл с именем ASM_GENERATED_FILE.uum32asm в директории \"" + getDirectory(masmFilePath) + "\"");
        return false;
    }

    QTextStream outAsmStream(&outAsmFile);
    QString bufferLine;                     // Используется для сохранения пользовательских комментариев и разметки в целом
    bool macroArea = false;

    outAsmStream.setCodec("UTF-8");

    if(!addMlbToBase(masmFilePath, true))
        return false;

    while(stream.readLineInto(&line))
    {
        bufferLine = line;

        console.inc();
        purifyLine(line);

        if(line.isEmpty())
        {
            outAsmStream << bufferLine << endl;
            continue;
        }

        QString mlbPath = parseIncludeKeyword(line);

        if(!mlbPath.isEmpty())
        {
            if(!addMlbToBase(getDirectory(masmFilePath) + mlbPath))
                return false;

            deleteEmptyLibraries();
        }

        else
        {
            if(macroArea == false)
            {
                QString::size_type retCode = line.indexOf("macro", Qt::CaseInsensitive);

                if(retCode == -1)
                {
                    QStringList deployedMacroCode;
                    quint16 retCode = MacroCallDeployer(&console, &database).deployMacroCall(line, deployedMacroCode);

                    if(retCode == 0)                          // Вызов макро не найден -> помещаем в файл исходную строку
                        outAsmStream << bufferLine << endl;
                    else if(retCode == 1)                     // Вызов макро найден -> помещаем в файл развернутое макроопределение
                    {
                        for(QStringList::size_type iter = 0; iter < deployedMacroCode.size(); ++iter)
                        {
                            /* Анализируем, надо ли добавлять \t (Если есть метка - не надо, иначе - надо) */
                            if(deployedMacroCode[iter].indexOf(':') != -1)
                                outAsmStream << deployedMacroCode[iter] << endl;
                            else
                                outAsmStream << '\t' + deployedMacroCode[iter] << endl;
                        }
                    }
                    else // Вознила ошибка
                        return 2;
                }

                else
                    macroArea = true;
            }

            else if(line.indexOf("mend", 0, Qt::CaseInsensitive) != -1)
                    macroArea = false;
        }
    }

    outAsmFile.close();

    return true;
}

void Parser::purifyLine(QString &line)
{
    for(QString::size_type i = 0; i < line.size(); ++i) // Ищем признак начала комментария
    {
        if(line[i] == ';') // Признак начала комментария
        {
            line.remove(i, line.size() - i); // Удаляем всё, начиная от комментария до конца строки
            break;
        }
    }

    if(line.indexOf('\'') == -1)  // Если в строке не содержится объявление пользовательской строки, прим.: | string: byte 'he\t\t\lo!' |
        line = line.simplified(); // удаляем все "лишние" пробелы
}

QString Parser::parseIncludeKeyword(const QString &line)
{
    int openQuoteIndex = line.indexOf('\'');

    if(openQuoteIndex != -1) // Чтобы не посчитать include в определении строки за директиву, не будем проверять строки, содержащиие
        return QString();    // одинарные кавычки, пример: | string: byte ' include "path" ' |

    int includeIndex = line.indexOf("include", 0, Qt::CaseInsensitive);

    if(includeIndex == -1) // Ключевое слово "include" - не найдено
        return QString();

    // На данном этапе, считаем, что все пробелы до include удалены (см. purifyLine())
    // -> если i в include не с индексом 0, значит в строке есть некорректные символы

    if(includeIndex != 0)
    {
        console |= "Некорректный символ в определнии <b><i>include</i></b>";
        return QString();
    }

    includeIndex += QString("include").size(); // Перепрыгиваем за include на пробел

    // После ключевого слова include должен идти символ табуляции / пробел, если это не так,
    // то определение include не корректно
    if(!line[includeIndex].isSpace())
    {
        console |= "Некорректный символ в определнии <b><i>include</i></b>";
        return QString();
    }

    ++includeIndex; // Перепрыгиваем на открывающую кавычку

    if(line[includeIndex] != '\"')
    {
        console |= "Не найдена открывающая кавычка в определении <b><i>include</i></b>";
        return QString();
    }

    bool closeQuoteSign = false; // Признак закрывающей кавычки
    QString filename;            // Формируемое имя файла, заданное в кавычках после include

    for(int iter = includeIndex + 1; !closeQuoteSign && iter < line.size(); ++iter)
    {
        if(line[iter] != '\"')
            filename += line[iter];
        else                        // Закрывающая кавычка найдена, цикл можно прекратить (см. условие выхода)
            closeQuoteSign = true;
    }

    if(closeQuoteSign == false)
    {
        console |= "Не найдена закрывающая кавычка в определении <b><i>include</i></b>";
        return QString();
    }

    int dotIndex = filename.indexOf('.');

    if(dotIndex == -1)
        filename += ".uum32mlb";

    return filename;
}

bool Parser::addMlbToBase(const QString &path, bool isFirstEntry)
{
    static QStringList includeFilePathes; // Сюда сохраняются пути файлов для избежания рекурсивных вызовов.

    // Проверяем, не было ли такого пути ранее
    for(QStringList::size_type i = 0; i < includeFilePathes.size(); ++i)
    {
        if(includeFilePathes[i] == path)
        {
            console < "Рекусирвное включение файлов [не поддерживается]";
            includeFilePathes.clear();
            return false;
        }
    }

    if(isFirstEntry != true)
        includeFilePathes += path; // Добавляем текущий mlb, чтобы избежать его включения в себя в дальнейшем

    QFile mlbFile(path);

    QString fpBuffer = console.getCurrentFile(); // Сохраняем текущие настройки
    quint32 clBuffer = console.getCurrentLine(); // консоли

    console.resetCurrentLine();     // Устанавливаем новые параметры консоли
    console.setCurrentFile(path);

    if(!mlbFile.open(QIODevice::Text | QIODevice::ReadOnly))
    {
        console < "Не удалось открыть файл \"" + path + '\"';
        includeFilePathes.clear();
        return false;
    }

    database.push_back(Library());
    database.last().libName = path;

    auto currLibIndex = database.size() - 1; // Поскольку функция может вызываться рекурсивно, то нет
                                             // гарантии, что при обращении к последней библиотеке, вернется
                                             // текущая библиотека, так как могут быть добавлены ещё библиотеки
    QTextStream mlbStream(&mlbFile);
    QString line;
    bool macroArea = false;

    while(mlbStream.readLineInto(&line))
    {
        console.inc();
        purifyLine(line);

        if(line.isEmpty())
            continue;

        QString mlbPath = parseIncludeKeyword(line);

        if(!mlbPath.isEmpty())
        {
            if(!addMlbToBase(getDirectory(masmFilePath) + mlbPath))
            {
                includeFilePathes.clear();
                return false;
            }
        }

        else
        {
            if(macroArea == false) // Управление находится вне области действия макроопределения
            {
                quint16 retCode = MacroKeywordParser(&console, &database).parseMacroKeyword(line, currLibIndex);

                /***
                 * retCode:
                 *      0 - macro не найдено
                 *      1 - macro найдено
                 *      2 - возникла ошибка
                 ***/

                if(retCode == 0)
                {
                    if(isFirstEntry)
                        continue;
                    else
                    {
                        console < "Некорректный символ вне macro определения";
                        return false;
                    }
                }
                else if(retCode == 1) // Добавление имени макроса и параметров происходит в parseMacroKeyword()
                    macroArea = true;

                else // Сообщение о самой ошибке выводится в функции parseMacroKeyword()
                {
                    includeFilePathes.clear();
                    return false;
                }
            }

            else
            {   
                if(line.indexOf("mend", 0, Qt::CaseInsensitive) != -1)
                {
                    line.remove("mend", Qt::CaseInsensitive);
                    purifyLine(line);

                    macroArea = false;

                    if(line.isEmpty())
                        continue;
                }

                QStringList deployedMacroCode;
                quint16 retCode = MacroCallDeployer(&console, &database).deployMacroCall(line, deployedMacroCode);

                if(retCode == 0) // Макровызов не найден, подставляем
                    database[currLibIndex].macroLabelVec.last().sourceCode += line;
                else if(retCode == 1) // Макровызов найден
                    database[currLibIndex].macroLabelVec.last().sourceCode += deployedMacroCode;
                else // Произошла ошибка при обработке макро
                {
                    includeFilePathes.clear();
                    return false;
                }

            }
        }
    }

    console.setCurrentFile(fpBuffer); // Восстанавливаем настройки
    console.setCurrentLine(clBuffer); // консоли

    includeFilePathes.removeAt(currLibIndex); // Удаляем текущую библиотеку из списка подключенных

    return true;
}

void Parser::deleteEmptyLibraries()
{
    for(Database::size_type iter = 0; iter < database.size(); )
    {
        if(database[iter].macroLabelVec.isEmpty())
            database.remove(iter);
        else
            ++iter;
    }
}



